@* 
Main view to load if no data is present.
The user then can select a file he already has or create a new one
*@

@* keep the eckige klammern to add info where the log originated from -> generics C# *@
@inject ILogger<NavBar> Logger;
@inject IFileSystemAccessService FileSystemAccessService;
@inject IASBNDataService dataService;
@inject IFileHandleManager fileHandleManager;
@inject IFileHandleProvider fileHandleProvider;

@using KristofferStrube.Blazor.FileSystem;



<div class="container-fluid mt-3 p-0">

    @* Hide the load file buttons & display a warning if the browser is not supported *@
    @if (!_isSupported)
    {
        <UnsupportedBrowserHelp />
    }
    else
    {
        <div>
            <button type="button" class="btn btn-outline-secondary" @onclick="CreateNewFile">Create New</button>
            <button type="button" class="btn btn-outline-dark" @onclick="OpenAndReadFile">Open File</button>
        </div>
    }
    
</div>


@code {
    PermissionState writePermissionState;
    private bool _isSupported;

    // Callback function
    [Parameter]
    public Func<Task> OnCallback { get; set; }

    // Figure out wether the used browser is supported or not!
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _isSupported = await FileSystemAccessService.IsSupportedAsync();
            StateHasChanged();
        }
    }


    // Let the user pick a file through the OS file system and then add it to our FileHandleManager
    private async Task OpenAndReadFile()
    {
        FileSystemFileHandle[]? fileHandles; 
        try
        {
            // Can only open one file at a time
            fileHandles = await FileSystemAccessService.ShowOpenFilePickerAsync();
        }
        catch (JSException ex)
        {
            // Handle Exception or cancelation of File Access prompt, returns empty Task if so
            Console.WriteLine(ex);
            return;
        }

        // The "using" block here makes sure we don't have a memory leak, because
        // "DisposeAsync" will be called at the end of the using scope.
        await using (var fileHandle = fileHandles.Single()) {
            if (fileHandle == null) {
                // TODO: throw new exception here
                // throw new FileNotFoundException("Never received fileHandle, please try again.");
                Logger.LogWarning("Opened file, but never received fileHandle.");
                return;
            }
            fileHandleManager.AddReplaceFileHandle(fileHandle);

            // await and process data being converted to JSON objects, was this as intended?
            await dataService.ReadData();

            // make sure we have write access
            writePermissionState = await fileHandle.RequestPermissionAsync(new() {Mode = FileSystemPermissionMode.ReadWrite });
            
            // Callback to the parent component
            await OnCallback.Invoke();

            // TODO: Handle what happens when the user denies write access -> show info button to retrigger the popup
        }
    }

    public async Task CreateNewFile() 
    {
        FileSystemFileHandle? fileHandles;
        try
        {
            fileHandles = await FileSystemAccessService.ShowSaveFilePickerAsync();
        }
        catch (JSException ex)
        {
            // Handle Exception or cancelation of File Access prompt
            Console.WriteLine(ex);
            return;
        }

        // The "using" block here makes sure we don't have a memory leak, because
        // "DisposeAsync" will be called at the end of the using scope.
        await using (var fileHandle = fileHandles) 
        {
            if (fileHandle == null) 
            {
                // TODO: add new exception here as well?
                Logger.LogWarning("Got file location, but never received fileHandle.");
                return;
            }
            fileHandleManager.AddReplaceFileHandle(fileHandle);

            // await and process data being converted to JSON objects, was this as intended?
            await dataService.WriteData();

            // make sure we have write access
            writePermissionState = await fileHandle.RequestPermissionAsync(new() {Mode = FileSystemPermissionMode.ReadWrite });

            // Callback to the parent component
            await OnCallback.Invoke();
        }
    }
}